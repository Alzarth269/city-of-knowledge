<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City of Knowledge - 3D Final Perfected</title>
    
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <style>
        :root { --house-color: #03A9F4; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; background: #f0f2f5; color: #333; overflow: hidden; }
        .app-container { display: flex; height: 100vh; }
        .game-area { flex: 1; position: relative; }
        #game-canvas { width: 100%; height: 100%; display: block; }
        .controls-panel { width: 320px; background: rgba(255, 255, 255, 0.98); padding: 20px; box-shadow: -5px 0 15px rgba(0,0,0,0.1); overflow-y: auto; z-index: 10; }
        #info-panel { background: #fff; padding: 15px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); margin-bottom: 20px; }
        #info-panel h2 { margin: 0; font-size: 1.3em; display: flex; align-items: center; gap: 8px; }
        #info-panel h2 input { border: none; font-size: 1em; font-weight: bold; width: 100%; padding: 8px; border-radius: 6px; background: #f5f5f5; transition: all 0.2s; }
        #info-panel h2 input:focus { outline: 2px solid var(--house-color); background: white; }
        #info-panel p { margin: 10px 0 0 0; font-size: 1.1em; }
        #info-panel p span { font-weight: bold; color: var(--house-color); }
        .control-group { margin-bottom: 25px; }
        .control-group h3 { margin: 0 0 12px 0; font-size: 1.2em; color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 8px; }
        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button { padding: 12px; border: none; border-radius: 8px; background: #3498db; color: white; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 5px; }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(52, 152, 219, 0.4); }
        button:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; box-shadow: none; }
        #build-instructions { font-style: italic; color: #7f8c8d; margin-top: 15px; min-height: 20px; padding: 10px; background: #ecf0f1; border-radius: 6px; }
        .hidden { display: none !important; }
        #tooltip { position: absolute; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 6px; z-index: 100; pointer-events: none; font-size: 0.9em; max-width: 200px; text-align: center; line-height: 1.4; }
        #modal-backdrop { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.7); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .modal { background: white; padding: 25px; border-radius: 12px; min-width: 500px; max-width: 90vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-top: 5px solid #3498db; }
        .modal h2 { margin-top: 0; color: #2c3e50; }
        .modal .close-btn { float: right; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #7f8c8d; }
        .loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #2c3e50; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5em; z-index: 2000; transition: opacity 0.5s; }
        .history-item, .project-item { border: 1px solid #ddd; padding: 12px; margin-bottom: 10px; border-radius: 6px; }
        .history-item summary, .project-item h3 { font-weight: bold; cursor: pointer; }
        .danger { background: #e74c3c !important; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="game-area">
            <canvas id="game-canvas"></canvas>
            <div id="tooltip" class="hidden"></div>
            <div id="loading-overlay" class="loading-overlay"><div>ƒêang d·ª±ng th√†nh ph·ªë 3D...</div></div>
        </div>
        
        <div class="controls-panel">
            <div id="info-panel">
                <h2><input type="text" id="city-name-input" placeholder="T√™n th√†nh ph·ªë"></h2>
                <p>D√¢n s·ªë: <span id="population-display">0</span></p>
            </div>
            <div class="control-group">
                <h3>üèóÔ∏è X√¢y d·ª±ng & Quy ho·∫°ch</h3>
                <div class="button-grid">
                    <button data-type="KNOWLEDGE_HOUSE">üè† Nh√†</button>
                    <button data-type="FACTORY" id="build-factory-btn" disabled>üè≠ Nh√† m√°y</button>
                    <button data-type="PARK" id="build-park-btn" disabled>üå≥ C√¥ng vi√™n</button>
                    <button data-type="ROAD">üõ£Ô∏è ƒê∆∞·ªùng</button>
                    <button data-tool="MOVE">‚úã Di chuy·ªÉn</button>
                    <button data-tool="DESTROY_ROAD">üí£ Ph√° ƒë∆∞·ªùng</button>
                </div>
            </div>
            <div class="control-group">
                <h3>üíæ Qu·∫£n l√Ω</h3>
                <div class="button-grid">
                    <button id="save-game-btn">üíæ L∆∞u Game</button>
                    <button id="load-game-btn">üìÇ T·∫£i Game</button>
                    <input type="file" id="load-game-input" accept=".json" class="hidden">
                </div>
            </div>
            <div class="control-group">
                <h3>‚ÑπÔ∏è H∆∞·ªõng d·∫´n</h3>
                <p id="build-instructions">Ch·ªçn c√¥ng c·ª• ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                <p style="font-size: 0.9em; color: #7f8c8d;">
                    <strong>ƒêi·ªÅu khi·ªÉn 3D:</strong><br>
                    ‚Ä¢ Gi·ªØ chu·ªôt tr√°i + di chuy·ªÉn ƒë·ªÉ xoay<br>
                    ‚Ä¢ LƒÉn chu·ªôt ƒë·ªÉ zoom<br>
                    ‚Ä¢ Gi·ªØ chu·ªôt ph·∫£i + di chuy·ªÉn ƒë·ªÉ pan
                </p>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="modal-backdrop" class="hidden">
        <div id="knowledge-house-modal" class="modal hidden"><button class="close-btn">&times;</button><h2 id="kh-modal-title"></h2><p>C·∫•p ƒë·ªô: <span id="kh-modal-level"></span> | D√¢n s·ªë: <span id="kh-modal-population"></span></p><h3>L·ªãch s·ª≠ N√¢ng c·∫•p</h3><div id="kh-history-list" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;"></div><button id="kh-upgrade-btn">‚¨ÜÔ∏è N√¢ng c·∫•p</button> <button id="kh-destroy-btn" class="danger">üóëÔ∏è Ph√° h·ªßy</button></div>
        <div id="select-certificate-modal" class="modal hidden"><button class="close-btn">&times;</button><h2>Ch·ªçn Ch·ª©ng nh·∫≠n</h2><p>Ch·ªçn m·ªôt th√†nh qu·∫£ ƒë·ªÉ ghi v√†o l·ªãch s·ª≠ ng√¥i nh√† n√†y.</p><select id="certificate-select" style="width: 100%; margin-bottom: 15px; padding: 8px;"></select><button id="confirm-upgrade-btn">‚úÖ X√°c nh·∫≠n</button></div>
        <div id="factory-modal" class="modal hidden"><button class="close-btn">&times;</button><h2>üè≠ Nh√† m√°y</h2><p>C√°c d·ª± √°n ƒëang th·ª±c hi·ªán.</p><div id="projects-list"></div><button id="create-knowledge-project-btn">‚ûï T·∫°o D·ª± √°n Ki·∫øn th·ª©c</button></div>
        <div id="park-modal" class="modal hidden"><button class="close-btn">&times;</button><h2>üå≥ C√¥ng vi√™n</h2><p>C√°c k·∫ø ho·∫°ch gi·∫£i tr√≠ ƒëang th·ª±c hi·ªán.</p><div id="recreation-projects-list"></div><button id="create-recreation-project-btn">‚ûï L√™n k·∫ø ho·∫°ch Gi·∫£i tr√≠</button></div>
        <div id="create-project-modal" class="modal hidden"><button class="close-btn">&times;</button><h2 id="project-modal-title"></h2><form id="project-form"><input type="text" id="project-name" required placeholder="T√™n d·ª± √°n" style="padding: 8px; margin-bottom: 10px;"><div id="project-target-wrapper" style="margin-bottom: 10px;"><select id="project-target-building" required style="width: 100%; padding: 8px;"></select></div><label>C√°c C√¥ng vi·ªác c·∫ßn l√†m:</label><div id="tasks-container" style="margin-bottom: 10px;"><input type="text" class="task-input" required placeholder="C√¥ng vi·ªác ƒë·∫ßu ti√™n" style="padding: 8px;"></div><button type="button" id="add-task-btn" style="margin-bottom: 15px;">‚ûï Th√™m C√¥ng vi·ªác</button><div style="text-align:right;"><button type="submit">üíæ L∆∞u D·ª± √°n</button></div></form></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let gameState = {
            cityName: 'Th√†nh ph·ªë Ki·∫øn th·ª©c',
            inventory: { certificates: [], recreation_certificates: 0 },
            city: { buildings: [] },
            projects: []
        };

        const GRID_SIZE = 20, TILE_SIZE = 2;
        const TERRAIN = { MOUNTAIN: [0, 1], SAND: [16, 17], SEA: [18, 19] };
        const POPULATION_UNLOCKS = { FACTORY: 50, PARK: 100 };
        const POP_BY_LEVEL = { 1: 10, 2: 25, 3: 50, 4: 100, 5: 200, 6: 400 };
        const PARK_AOE_BONUS = 4;
        
        let currentTool = null, activeBuilding = null, movingBuilding = null, tempMoveMesh = null, isDrawing = false;
        let scene, camera, renderer, orbitControls, raycaster, mouse, groundPlane, gridHelper, highlightMesh;
        let buildingMeshes = new Map();
        let roadPreviewMeshes = new Map();
        
        let destroyRoadStartPoint = null;

        const canvas = document.getElementById('game-canvas'), tooltip = document.getElementById('tooltip'), loadingOverlay = document.getElementById('loading-overlay'),
        infoPanel = { nameInput: document.getElementById('city-name-input'), population: document.getElementById('population-display') },
        controlsPanel = { main: document.querySelector('.controls-panel'), buildFactoryBtn: document.getElementById('build-factory-btn'), buildParkBtn: document.getElementById('build-park-btn'),
        instructions: document.getElementById('build-instructions'), saveBtn: document.getElementById('save-game-btn'), loadBtn: document.getElementById('load-game-btn'), loadInput: document.getElementById('load-game-input') },
        modalBackdrop = document.getElementById('modal-backdrop'), allModals = document.querySelectorAll('.modal'),
        modals = { kh: document.getElementById('knowledge-house-modal'), selectCert: document.getElementById('select-certificate-modal'),
        factory: document.getElementById('factory-modal'), park: document.getElementById('park-modal'), project: document.getElementById('create-project-modal') };
        
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
            const gameArea = document.querySelector('.game-area');
            camera = new THREE.PerspectiveCamera(60, gameArea.clientWidth / gameArea.clientHeight, 0.1, 1000);
            camera.position.set(20, 30, 20);
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(gameArea.clientWidth, gameArea.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.maxPolarAngle = Math.PI / 2.2;
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.7);
            sun.position.set(50, 50, 25);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            sun.shadow.camera.left = -40; sun.shadow.camera.right = 40;
            sun.shadow.camera.top = 40; sun.shadow.camera.bottom = -40;
            scene.add(sun);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            const planeGeo = new THREE.PlaneGeometry(GRID_SIZE * TILE_SIZE, GRID_SIZE * TILE_SIZE);
            groundPlane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ visible: false }));
            groundPlane.rotation.x = -Math.PI / 2;
            scene.add(groundPlane);
            gridHelper = new THREE.GridHelper(GRID_SIZE * TILE_SIZE, GRID_SIZE, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            gridHelper.position.y = 0.11;
            scene.add(gridHelper);
            highlightMesh = new THREE.Mesh(new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
            highlightMesh.rotation.x = -Math.PI / 2;
            highlightMesh.position.y = 0.12;
            highlightMesh.visible = false;
            scene.add(highlightMesh);
            createTerrain();
            animate();
            setTimeout(() => { loadingOverlay.style.opacity = '0'; setTimeout(() => loadingOverlay.style.display = 'none', 500); }, 500);
        }

        function createTerrain() {
            const terrainGroup = new THREE.Group();
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    let height = 0.2, color = 0x8BC34A;
                    if (TERRAIN.MOUNTAIN.includes(x)) { height = 2 + Math.random() * 2; color = 0x616161; }
                    else if (TERRAIN.SAND.includes(x)) { color = 0xFFD54F; }
                    else if (TERRAIN.SEA.includes(x)) { height = 0.1; color = 0x4FC3F7; }
                    const geo = new THREE.BoxGeometry(TILE_SIZE, height, TILE_SIZE);
                    const mat = new THREE.MeshLambertMaterial({ color });
                    const tile = new THREE.Mesh(geo, mat);
                    tile.position.set((x - GRID_SIZE/2 + 0.5) * TILE_SIZE, height/2 - 0.1, (y - GRID_SIZE/2 + 0.5) * TILE_SIZE);
                    tile.receiveShadow = true;
                    terrainGroup.add(tile);
                }
            }
            scene.add(terrainGroup);
        }

        function createBuildingMesh(building) {
            let mesh; const level = building.level || 1;
            const mat = new THREE.MeshLambertMaterial();
            const yOffset = 0.11; 
            if (building.type === 'KNOWLEDGE_HOUSE') {
                const height = 1 + (level - 1) * 1.2;
                const width = 1 + Math.min(level - 1, 3) * 0.1;
                const geo = new THREE.BoxGeometry(width, height, width);
                mat.color.set(0x03A9F4);
                mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = height / 2 + yOffset;
            } else if (building.type === 'FACTORY') {
                const geo = new THREE.BoxGeometry(1.5, 2, 1.5); mat.color.set(0xFFC107);
                mesh = new THREE.Mesh(geo, mat); mesh.position.y = 1 + yOffset;
            } else if (building.type === 'PARK') {
                const geo = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 8); mat.color.set(0x4CAF50);
                mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.1 + yOffset;
            } else if (building.type === 'ROAD') {
                const geo = new THREE.BoxGeometry(TILE_SIZE, 0.1, TILE_SIZE); mat.color.set(0x757575);
                mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.05 + yOffset;
            }
            if (mesh) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { buildingId: building.id, type: 'building', buildingRef: building };
                const x = (building.position.x - GRID_SIZE / 2 + 0.5) * TILE_SIZE;
                const z = (building.position.y - GRID_SIZE / 2 + 0.5) * TILE_SIZE;
                mesh.position.x = x; mesh.position.z = z;
            }
            return mesh;
        }

        function renderScene() {
            buildingMeshes.forEach(mesh => scene.remove(mesh));
            buildingMeshes.clear();
            gameState.city.buildings.forEach(b => {
                const mesh = createBuildingMesh(b);
                if (mesh) {
                    if (b.isInvalid) mesh.material.emissive.setHex(0xff0000);
                    buildingMeshes.set(b.id, mesh);
                    scene.add(mesh);
                }
            });
        }

        function animate() { requestAnimationFrame(animate); orbitControls.update(); renderer.render(scene, camera); }
        function onWindowResize() { const area = document.querySelector('.game-area'); camera.aspect = area.clientWidth / area.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(area.clientWidth, area.clientHeight); }
        
        function updateInfoPanel() { infoPanel.nameInput.value = gameState.cityName; const population = calculateTotalPopulation(); const nextUnlock = population < POPULATION_UNLOCKS.FACTORY ? POPULATION_UNLOCKS.FACTORY : (population < POPULATION_UNLOCKS.PARK ? POPULATION_UNLOCKS.PARK : 'Max'); infoPanel.population.textContent = `${population} (M·ªü kh√≥a: ${nextUnlock} d√¢n)`; }
        function updateBuildMenu() { const pop = calculateTotalPopulation(); controlsPanel.buildFactoryBtn.disabled = pop < POPULATION_UNLOCKS.FACTORY || gameState.city.buildings.some(b => b.type === 'FACTORY'); controlsPanel.buildParkBtn.disabled = pop < POPULATION_UNLOCKS.PARK; }
        function calculateTotalPopulation() { let totalPop = 0; const parks = gameState.city.buildings.filter(b => b.type === 'PARK'); gameState.city.buildings.forEach(b => { if (b.type === 'KNOWLEDGE_HOUSE') { totalPop += POP_BY_LEVEL[b.level] || 0; if (parks.some(p => Math.abs(p.position.x - b.position.x) <= 1 && Math.abs(p.position.y - b.position.y) <= 1 && p.id !== b.id)) { totalPop += PARK_AOE_BONUS; } } }); return totalPop; }
        function isPositionValid(x, y) { return !(TERRAIN.MOUNTAIN.includes(x) || TERRAIN.SAND.includes(x) || TERRAIN.SEA.includes(x)); }
        
        function setTool(type, detail = null) {
            const newToolKey = detail || type;
            if (currentTool && currentTool.key === newToolKey) {
                resetTool();
                return;
            }
            resetTool(); 
            currentTool = { type, detail, key: newToolKey };
            movingBuilding = null;
            highlightMesh.visible = true;
            gridHelper.visible = true; 
            orbitControls.enabled = !(type === 'BUILD' && detail === 'ROAD') && !(type === 'DESTROY_ROAD'); 
            let text = '';
            if (type === 'BUILD') { text = `Nh·∫•p ho·∫∑c k√©o th·∫£ ƒë·ªÉ x√¢y ${detail.replace('_', ' ')}.`; }
            else if (type === 'MOVE') { text = 'Nh·∫•p v√†o m·ªôt t√≤a nh√† ƒë·ªÉ di chuy·ªÉn.'; }
            else if (type === 'DESTROY_ROAD') { text = 'Ch·ªçn ƒëi·ªÉm ƒê·∫¶U c·ªßa ƒëo·∫°n ƒë∆∞·ªùng c·∫ßn ph√°.'; }
            controlsPanel.instructions.textContent = text;
        }

        function resetTool() {
            if (destroyRoadStartPoint) {
                const building = getBuildingAt(destroyRoadStartPoint.x, destroyRoadStartPoint.y);
                if (building) {
                    const mesh = buildingMeshes.get(building.id);
                    if (mesh) mesh.material.color.set(0x757575);
                }
            }
            destroyRoadStartPoint = null;
            
            currentTool = null; movingBuilding = null; isDrawing = false;
            if (tempMoveMesh) { scene.remove(tempMoveMesh); tempMoveMesh = null; }
            highlightMesh.visible = false;
            roadPreviewMeshes.forEach(p => scene.remove(p.mesh));
            roadPreviewMeshes.clear();
            
            orbitControls.enabled = true; 
            controlsPanel.instructions.textContent = 'Ch·ªçn c√¥ng c·ª• ƒë·ªÉ b·∫Øt ƒë·∫ßu';
        }
        
        function placeBuilding(x, y, type) { let name = type; if (type === 'KNOWLEDGE_HOUSE') name = prompt('ƒê·∫∑t t√™n cho ki·∫øn th·ª©c:'); else if (type === 'PARK') name = 'C√¥ng vi√™n'; if (!name && type === 'KNOWLEDGE_HOUSE') return; const newBuilding = { id: `b_${Date.now()}`, type, name, level: 1, position: { x, y } }; if (type === 'KNOWLEDGE_HOUSE') newBuilding.upgradeHistory = []; gameState.city.buildings.push(newBuilding); }
        function getBuildingAt(x, y) { return gameState.city.buildings.find(b => b.position && b.position.x === x && b.position.y === y); }
        function getAdjacentBuildings(x, y) { const adj = []; [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(([dx, dy]) => { const b = getBuildingAt(x + dx, y + dy); if (b) adj.push(b); }); return adj; }
        function closeModal() { modalBackdrop.classList.add('hidden'); allModals.forEach(m => m.classList.add('hidden')); if(!movingBuilding) activeBuilding = null; }
        
        function openBuildingModal(building) {
            activeBuilding = building; if (building.isInvalid) { alert('V·ªã tr√≠ kh√¥ng h·ª£p l·ªá! Vui l√≤ng di chuy·ªÉn c√¥ng tr√¨nh n√†y.'); setTool('MOVE'); return; }
            modalBackdrop.classList.remove('hidden');
            if (building.type === 'KNOWLEDGE_HOUSE') {
                modals.kh.classList.remove('hidden'); modals.kh.querySelector('#kh-modal-title').textContent = building.name; modals.kh.querySelector('#kh-modal-level').textContent = building.level;
                modals.kh.querySelector('#kh-modal-population').textContent = POP_BY_LEVEL[building.level] || 0;
                const historyList = modals.kh.querySelector('#kh-history-list'); historyList.innerHTML = '';
                if (building.upgradeHistory && building.upgradeHistory.length > 0) {
                    building.upgradeHistory.forEach(cert => {
                        const item = document.createElement('details'); item.className = 'history-item';
                        let tasksHtml = '<ul>'; cert.tasks.forEach(t => tasksHtml += `<li>${t.description}</li>`); tasksHtml += '</ul>';
                        item.innerHTML = `<summary>${cert.name}</summary>${tasksHtml}`;
                        historyList.appendChild(item);
                    });
                } else { historyList.innerHTML = '<p>Ch∆∞a c√≥ l·ªãch s·ª≠.</p>'; }
            } else if (building.type === 'FACTORY') { modals.factory.classList.remove('hidden'); renderProjectList();
            } else if (building.type === 'PARK') { modals.park.classList.remove('hidden'); renderProjectList(); }
        }

        function migrateSaveData(loadedState) { if (typeof loadedState.inventory.certificates === 'number') { const c = loadedState.inventory.certificates; loadedState.inventory.certificates = []; for(let i=0; i<c; i++) { loadedState.inventory.certificates.push({ id: `legacy_${i}`, name: `Ch·ª©ng nh·∫≠n c≈© #${i+1}`, tasks: [{description: 'D·ªØ li·ªáu c≈©', completed: true}] }); } } loadedState.city.buildings.forEach(b => { if (b.type === 'KNOWLEDGE_HOUSE' && !b.upgradeHistory) { b.upgradeHistory = []; for(let i=1; i < b.level; i++) { b.upgradeHistory.push({ id: `legacy_up_${b.id}_${i}`, name: `N√¢ng c·∫•p Lvl ${i+1} (D·ªØ li·ªáu c≈©)`, tasks: [{description: 'Chuy·ªÉn ƒë·ªïi t·ª± ƒë·ªông', completed: true}] }); } } }); return loadedState; }
        function openProjectModal(type) { closeModal(); const form = modals.project.querySelector('form'); form.reset(); form.dataset.projectType = type; modals.project.querySelector('#tasks-container').innerHTML = '<input type="text" class="task-input" required placeholder="C√¥ng vi·ªác ƒë·∫ßu ti√™n" style="padding: 8px;">'; const targetWrapper = modals.project.querySelector('#project-target-wrapper'); if (type === 'KNOWLEDGE') { modals.project.querySelector('#project-modal-title').textContent = 'T·∫°o D·ª± √°n Ki·∫øn th·ª©c'; targetWrapper.classList.remove('hidden'); const select = targetWrapper.querySelector('select'); select.innerHTML = ''; gameState.city.buildings.filter(b => b.type === 'KNOWLEDGE_HOUSE').forEach(h => { const o = document.createElement('option'); o.value = h.id; o.textContent = `${h.name} (Lvl ${h.level})`; select.appendChild(o); }); if(select.innerHTML === '') { alert('B·∫°n c·∫ßn x√¢y Nh√† Ki·∫øn th·ª©c tr∆∞·ªõc!'); return; } } else { modals.project.querySelector('#project-modal-title').textContent = 'L√™n k·∫ø ho·∫°ch Gi·∫£i tr√≠'; targetWrapper.classList.add('hidden'); } modalBackdrop.classList.remove('hidden'); modals.project.classList.remove('hidden'); }
        function renderProjectList() { const kList = modals.factory.querySelector('#projects-list'), rList = modals.park.querySelector('#recreation-projects-list'); kList.innerHTML = ''; rList.innerHTML = ''; const knowledgeProjects = gameState.projects.filter(p => p.type === 'KNOWLEDGE' && p.status === 'IN_PROGRESS'), recreationProjects = gameState.projects.filter(p => p.type === 'RECREATION' && p.status === 'IN_PROGRESS'); (knowledgeProjects.length > 0 ? knowledgeProjects : [{isEmpty: true, list: kList, type: 'Ki·∫øn th·ª©c'}]).concat(recreationProjects.length > 0 ? recreationProjects : [{isEmpty: true, list: rList, type: 'Gi·∫£i tr√≠'}]).forEach(p => { if (p.isEmpty) { p.list.innerHTML = `<p>Ch∆∞a c√≥ d·ª± √°n ${p.type} n√†o ƒëang th·ª±c hi·ªán.</p>`; return; } const targetList = p.type === 'KNOWLEDGE' ? kList : rList, item = document.createElement('div'); item.className = `project-item project-item-${p.type.toLowerCase()}`; const targetName = p.type === 'KNOWLEDGE' ? (gameState.city.buildings.find(b => b.id === p.targetBuildingId)?.name || 'Nh√† ƒë√£ b·ªã ph√° h·ªßy') : p.name; let tasksHtml = '<ul>'; p.tasks.forEach((task, i) => tasksHtml += `<li><input type="checkbox" id="task_${p.id}_${i}" data-pid="${p.id}" data-tidx="${i}" ${task.completed ? 'checked' : ''}><label for="task_${p.id}_${i}">${task.description}</label></li>`); tasksHtml += '</ul>'; const canProduce = p.tasks.every(t => t.completed), buttonHtml = `<button class="produce-btn" data-pid="${p.id}" ${!canProduce ? 'disabled' : ''}>Ho√†n th√†nh & S·∫£n xu·∫•t</button>`; item.innerHTML = `<h3>${p.name} ${p.type === 'KNOWLEDGE' ? `(Cho: ${targetName})` : ''}</h3> ${tasksHtml} ${buttonHtml}`; targetList.appendChild(item); }); }
        function handleProjectInteraction(e) { const pid = e.target.dataset.pid; if (!pid) return; const project = gameState.projects.find(p => p.id === pid); if (!project) return; if (e.target.type === 'checkbox') { const tidx = parseInt(e.target.dataset.tidx); project.tasks[tidx].completed = e.target.checked; renderProjectList(); } else if (e.target.classList.contains('produce-btn')) { if (project.type === 'KNOWLEDGE') { const newCert = { id: `cert_${Date.now()}`, name: project.name, tasks: project.tasks }; gameState.inventory.certificates.push(newCert); alert(`S·∫£n xu·∫•t th√†nh c√¥ng 1 "Ch·ª©ng nh·∫≠n: ${project.name}"!`); } else { gameState.inventory.recreation_certificates++; alert(`Ho√†n th√†nh k·∫ø ho·∫°ch gi·∫£i tr√≠!`); } project.status = 'COMPLETED'; renderProjectList(); } }
        
        // --- EVENT LISTENERS ---
        window.addEventListener('resize', onWindowResize);
        canvas.addEventListener('mousemove', e => { 
            const rect = canvas.getBoundingClientRect(); 
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1; 
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1; 
            raycaster.setFromCamera(mouse, camera); 
            const groundIntersects = raycaster.intersectObjects([groundPlane]); 
            if (groundIntersects.length > 0) { 
                const p = groundIntersects[0].point; 
                const gridX = Math.floor(p.x / TILE_SIZE + GRID_SIZE / 2); 
                const gridY = Math.floor(p.z / TILE_SIZE + GRID_SIZE / 2); 
                highlightMesh.position.set((gridX - GRID_SIZE/2 + 0.5) * TILE_SIZE, 0.12, (gridY - GRID_SIZE/2 + 0.5) * TILE_SIZE); 
                if (movingBuilding && tempMoveMesh) tempMoveMesh.position.set(highlightMesh.position.x, tempMoveMesh.position.y, highlightMesh.position.z); 
                
                if (isDrawing && currentTool?.type === 'BUILD' && currentTool?.detail === 'ROAD') {
                    const key = `${gridX},${gridY}`; 
                    if(isPositionValid(gridX, gridY) && !getBuildingAt(gridX, gridY) && !roadPreviewMeshes.has(key)) { 
                        const geo = new THREE.BoxGeometry(TILE_SIZE, 0.1, TILE_SIZE); 
                        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 }); 
                        const preview = new THREE.Mesh(geo, mat); 
                        preview.position.set(highlightMesh.position.x, 0.11, highlightMesh.position.z); 
                        scene.add(preview); 
                        roadPreviewMeshes.set(key, {mesh: preview, x: gridX, y: gridY}); 
                    }
                }
            }
            
            const buildingIntersects = raycaster.intersectObjects(Array.from(buildingMeshes.values())); 
            if (buildingIntersects.length > 0) { 
                const b = buildingIntersects[0].object.userData.buildingRef; 
                if (b && b.type === 'KNOWLEDGE_HOUSE') { 
                    tooltip.classList.remove('hidden'); 
                    tooltip.innerHTML = `<strong>${b.name}</strong><br>L·ªãch s·ª≠: ${b.upgradeHistory?.length || 0} ch·ª©ng nh·∫≠n`; 
                    tooltip.style.left = `${e.clientX + 15}px`; 
                    tooltip.style.top = `${e.clientY + 15}px`; 
                } else { 
                    tooltip.classList.add('hidden'); 
                } 
            } else { 
                tooltip.classList.add('hidden'); 
            }
        });
        canvas.addEventListener('mousedown', () => { if (currentTool && currentTool.type !== 'DESTROY_ROAD') isDrawing = true; });
        window.addEventListener('mouseup', () => { 
            if (isDrawing) { 
                isDrawing = false; 
                if (currentTool?.type === 'BUILD' && currentTool?.detail === 'ROAD') { 
                    roadPreviewMeshes.forEach(p => placeBuilding(p.x, p.y, 'ROAD')); 
                    renderScene(); 
                    resetTool(); 
                }
            } 
        });

        // --- NEW DESTROY ROAD MECHANISM ---
        canvas.addEventListener('click', e => {
            if (isDrawing) return;

            raycaster.setFromCamera(mouse, camera);
            const groundIntersects = raycaster.intersectObjects([groundPlane]);

            if (groundIntersects.length === 0) return;

            const p = groundIntersects[0].point;
            const x = Math.floor(p.x / TILE_SIZE + GRID_SIZE / 2);
            const y = Math.floor(p.z / TILE_SIZE + GRID_SIZE / 2);
            const clickedBuilding = getBuildingAt(x, y);

            if (currentTool?.type === 'DESTROY_ROAD') {
                // First click: select start point
                if (!destroyRoadStartPoint) {
                    if (!clickedBuilding || clickedBuilding.type !== 'ROAD') {
                        alert('ƒêi·ªÉm ƒë·∫ßu ph·∫£i l√† m·ªôt con ƒë∆∞·ªùng. Vui l√≤ng ch·ªçn l·∫°i.');
                        return;
                    }
                    
                    destroyRoadStartPoint = { x, y };
                    const mesh = buildingMeshes.get(clickedBuilding.id);
                    if (mesh) mesh.material.color.set(0xf1c40f);
                    controlsPanel.instructions.textContent = 'ƒê√£ ch·ªçn ƒëi·ªÉm ƒë·∫ßu. Ch·ªçn ƒëi·ªÉm CU·ªêI ƒë·ªÉ ph√° h·ªßy.';
                } 
                // Second click: select end point and destroy the road segment
                else {
                    const start = destroyRoadStartPoint;
                    const end = { x, y };
                    
                    // Validate that both points are roads
                    if (!clickedBuilding || clickedBuilding.type !== 'ROAD') {
                        alert('ƒêi·ªÉm cu·ªëi ph·∫£i l√† m·ªôt con ƒë∆∞·ªùng. Vui l√≤ng ch·ªçn l·∫°i.');
                        resetTool();
                        return;
                    }
                    
                    // Check if the points form a straight line (horizontal or vertical)
                    if (start.x !== end.x && start.y !== end.y) {
                        alert('ƒêo·∫°n ƒë∆∞·ªùng ph·∫£i l√† m·ªôt ƒë∆∞·ªùng th·∫≥ng (ngang ho·∫∑c d·ªçc).');
                        resetTool();
                        return;
                    }

                    // Generate all points on the straight line between start and end
                    const path = [];
                    if (start.x === end.x) { // Vertical line
                        const minY = Math.min(start.y, end.y);
                        const maxY = Math.max(start.y, end.y);
                        for (let i = minY; i <= maxY; i++) {
                            path.push({ x: start.x, y: i });
                        }
                    } else { // Horizontal line
                        const minX = Math.min(start.x, end.x);
                        const maxX = Math.max(start.x, end.x);
                        for (let i = minX; i <= maxX; i++) {
                            path.push({ x: i, y: start.y });
                        }
                    }

                    // Check if all points on the path are roads
                    const buildingsOnPath = path.map(pos => getBuildingAt(pos.x, pos.y));
                    const isPathValid = buildingsOnPath.every(b => b && b.type === 'ROAD');

                    if (isPathValid) {
                        const idsToDelete = new Set(buildingsOnPath.map(b => b.id));
                        gameState.city.buildings = gameState.city.buildings.filter(b => !idsToDelete.has(b.id));
                        alert(`ƒê√£ ph√° h·ªßy ${idsToDelete.size} ƒëo·∫°n ƒë∆∞·ªùng.`);
                        renderScene();
                    } else {
                        alert('ƒêo·∫°n ƒë∆∞·ªùng b·∫°n ch·ªçn kh√¥ng li√™n t·ª•c ho·∫∑c ch·ª©a √¥ kh√¥ng h·ª£p l·ªá.');
                    }
                    
                    resetTool();
                }
            } else if (currentTool?.type === 'MOVE') {
                if (movingBuilding) {
                    if (clickedBuilding) { alert('V·ªã tr√≠ ƒë√£ c√≥ c√¥ng tr√¨nh!'); return; }
                    if (!isPositionValid(x, y)) { alert('Kh√¥ng th·ªÉ di chuy·ªÉn ƒë·∫øn v√πng n√†y!'); return; }
                    if (movingBuilding.type !== 'ROAD' && !getAdjacentBuildings(x, y).some(b => b.type === 'ROAD')) { alert('Ph·∫£i ƒë·∫∑t c·∫°nh ƒë∆∞·ªùng!'); return; }
                    movingBuilding.position = { x, y };
                    movingBuilding.isInvalid = false;
                    renderScene();
                    resetTool();
                } else {
                    if (!clickedBuilding) return;
                    movingBuilding = clickedBuilding;
                    const mesh = buildingMeshes.get(clickedBuilding.id);
                    if (mesh) {
                        tempMoveMesh = mesh.clone();
                        tempMoveMesh.material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                        scene.add(tempMoveMesh);
                        scene.remove(mesh);
                        buildingMeshes.delete(clickedBuilding.id);
                    }
                    controlsPanel.instructions.textContent = 'Ch·ªçn v·ªã tr√≠ m·ªõi ƒë·ªÉ ƒë·∫∑t.';
                }
            } else if (currentTool?.type === 'BUILD') {
                if (!isPositionValid(x, y) || clickedBuilding) { alert('V·ªã tr√≠ kh√¥ng h·ª£p l·ªá!'); return; }
                if (currentTool.detail !== 'ROAD' && !getAdjacentBuildings(x, y).some(b => b.type === 'ROAD')) { alert('Ph·∫£i x√¢y c·∫°nh ƒë∆∞·ªùng!'); return; }
                placeBuilding(x, y, currentTool.detail);
                renderScene();
                resetTool();
            } else {
                if (clickedBuilding) {
                    openBuildingModal(clickedBuilding);
                }
            }
        });
        // --- END NEW DESTROY ROAD MECHANISM ---

        infoPanel.nameInput.addEventListener('change', e => gameState.cityName = e.target.value);
        controlsPanel.main.addEventListener('click', e => { if (e.target.tagName === 'BUTTON' && !e.target.disabled) { const type = e.target.dataset.type; const tool = e.target.dataset.tool; if (type) setTool('BUILD', type); if (tool) setTool(tool); } });
        modalBackdrop.addEventListener('click', e => { if (e.target === modalBackdrop || e.target.classList.contains('close-btn')) closeModal(); });
        controlsPanel.saveBtn.addEventListener('click', () => { const d = JSON.stringify(gameState, null, 2), b = new Blob([d], {type:"application/json"}), a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `${gameState.cityName.replace(/\s/g, '_')}_save.json`; a.click(); a.remove(); });
        controlsPanel.loadBtn.addEventListener('click', () => controlsPanel.loadInput.click());
        controlsPanel.loadInput.addEventListener('change', e => { const f = e.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = re => { try { let s = JSON.parse(re.target.result); if (!s.city) throw new Error('Invalid file'); s = migrateSaveData(s); s.city.buildings.forEach(b => b.isInvalid = b.position && !isPositionValid(b.position.x, b.position.y)); gameState = s; renderScene(); updateInfoPanel(); updateBuildMenu(); alert('T·∫£i game th√†nh c√¥ng!'); } catch (err) { alert('L·ªói: ' + err.message); }}; r.readAsText(f); e.target.value=null; });
        
        // --- MODAL EVENT LISTENERS ---
        modals.kh.querySelector('#kh-destroy-btn').addEventListener('click', () => { if (confirm(`Ph√° h·ªßy "${activeBuilding.name}"?`)) { gameState.city.buildings = gameState.city.buildings.filter(b => b.id !== activeBuilding.id); gameState.projects = gameState.projects.filter(p => p.targetBuildingId !== activeBuilding.id); closeModal(); renderScene(); updateInfoPanel(); }});
        modals.kh.querySelector('#kh-upgrade-btn').addEventListener('click', () => { 
            modals.kh.classList.add('hidden'); 
            const select = modals.selectCert.querySelector('#certificate-select');
            select.innerHTML = ''; const availableCerts = gameState.inventory.certificates;
            if (availableCerts.length === 0) { alert('B·∫°n kh√¥ng c√≥ ch·ª©ng nh·∫≠n n√†o!'); activeBuilding = null; return; } 
            availableCerts.forEach(cert => { const o = document.createElement('option'); o.value = cert.id; o.textContent = cert.name; select.appendChild(o); });
            modalBackdrop.classList.remove('hidden');
            modals.selectCert.classList.remove('hidden');
        });
        modals.selectCert.querySelector('#confirm-upgrade-btn').addEventListener('click', () => { 
            const certId = modals.selectCert.querySelector('#certificate-select').value; if (!certId || !activeBuilding) return; 
            const certIndex = gameState.inventory.certificates.findIndex(c => c.id === certId); if(certIndex === -1) return;
            if (activeBuilding.level >= 6) { alert('ƒê√£ ƒë·∫°t c·∫•p t·ªëi ƒëa!'); return; } 
            const [certToUse] = gameState.inventory.certificates.splice(certIndex, 1);
            activeBuilding.upgradeHistory.push(certToUse); activeBuilding.level++;
            alert(`N√¢ng c·∫•p th√†nh c√¥ng!`); closeModal(); renderScene(); updateInfoPanel(); 
        });
        
        modals.factory.querySelector('#create-knowledge-project-btn').addEventListener('click', () => openProjectModal('KNOWLEDGE'));
        modals.park.querySelector('#create-recreation-project-btn').addEventListener('click', () => openProjectModal('RECREATION'));
        modals.project.querySelector('form').addEventListener('submit', e => { e.preventDefault(); const form = e.target, type = form.dataset.projectType; const newProject = { id: `p_${Date.now()}`, type, name: form.querySelector('#project-name').value, status: 'IN_PROGRESS', tasks: Array.from(form.querySelectorAll('.task-input')).map(i => ({ description: i.value, completed: false })) }; if (type === 'KNOWLEDGE') { if(!form.querySelector('#project-target-building').value) { alert('Kh√¥ng c√≥ nh√† ƒë·ªÉ li√™n k·∫øt!'); return; } newProject.targetBuildingId = form.querySelector('#project-target-building').value; } gameState.projects.push(newProject); closeModal(); });
        document.getElementById('projects-list').addEventListener('click', handleProjectInteraction);
        document.getElementById('recreation-projects-list').addEventListener('click', handleProjectInteraction);
        modals.project.querySelector('#add-task-btn').addEventListener('click', () => { const i = document.createElement('input'); i.type = 'text'; i.className = 'task-input'; i.required = true; i.placeholder = 'C√¥ng vi·ªác ti·∫øp theo'; i.style.padding = '8px'; modals.project.querySelector('#tasks-container').appendChild(i); });
        
        initThreeJS();
        updateInfoPanel();
        updateBuildMenu();
    });
    </script>
</body>
</html>
